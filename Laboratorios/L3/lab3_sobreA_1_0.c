/* Main.c file generated by New Project wizard
 *
 * Created:   Sat Mar 12 2022
 * Processor: PIC18F45K22
 * Compiler:  MPLAB XC8
 */
#include <xc.h>
#include "config.h"
#include <stdbool.h>
#define _XTAL_FREQ 8000000

void updateInputRegisters(char *prevB, char *currB, char *prevE, char *currE)
{
    *prevB = *currB;
    *currB = PORTB;

    *prevE = *currE;
    *currE = PORTE;
}

bool detectEdge(char REG_prev, char REG_curr, char pin, char edge)
{
    REG_prev = REG_prev >> pin;
    REG_curr = REG_curr >> pin;

    char prev = REG_prev & 0x01;
    char curr = REG_curr & 0x01;

    if (prev == curr)
        return false;

    if (edge == 1)
        return (prev == 0 && curr == 1);
    else
        return (prev == 1 && curr == 0);
}

const char NUMBERS[] = {0b00111111, 0b00000110,
                        0b01011011, 0b01001111,
                        0b01100110, 0b01101101,
                        0b01111101, 0b00000111,
                        0b01111111, 0b01101111};

void config_PIC(void)
{
    ANSELA = 0;
    ANSELB = 0;
    ANSELC = 0;
    ANSELD = 0;
    ANSELE = 0;

    TRISA = 0;    // output
    TRISB = 0xFF; // input
    TRISC = 0;    // output
    TRISD = 0;    // output
    TRISE = 0xFF; // input

    PORTC = 0;
    PORTD = 0;
}

void displayOff()
{
    PORTA = 0;
}

void displayDigit(char digit, char display)
{
    PORTD = NUMBERS[digit];
    switch (display)
    {
        case 0: PORTAbits.RA0 = 1; break;
        case 1: PORTAbits.RA1 = 1; break;
        case 2: PORTAbits.RA2 = 1; break;
        case 3: PORTAbits.RA3 = 1; break;
    }
    __delay_us(50);
    PORTA = 0;
}

void displayNumber(int number)
{
    PORTA = 0;
    for (char display = 0; display < 4; ++display)
    {
        char digit = number % 10;
        displayDigit(digit, display);
        number = number / 10;
    }
}

void inputNumbers(int *contador, char *prevB, char *currB)
{
    if (detectEdge(*prevB, *currB, 0, 1)) *contador += 1;
    if (detectEdge(*prevB, *currB, 1, 1)) *contador += 10;
    if (detectEdge(*prevB, *currB, 2, 1)) *contador += 100;
    if (detectEdge(*prevB, *currB, 3, 1)) *contador += 1000;
    if (*contador > 9999) *contador = 0;
}

//DISPLAY binary 1 in PORTC if players wins the game
void winner() { PORTC = 0b00000001; }

//DISPLAY binary 2 in PORTC if players loses the game
void loser() { PORTC = 0b00000010; }

void main(void)
{
    config_PIC();

    char prevB, currB, prevE, currE;
    currB = PORTB;
    currE = PORTE;
    int contador = 0;
    bool game_running = false;

    while (true)
    {
        updateInputRegisters(&prevB, &currB, &prevE, &currE);
        //We wait actively for user to press RE0 to generate a number (game starts, although user can't input anything yet)
        if (detectEdge(prevE, currE, 0, 1))
        {
            game_running = true;
            const int ran = rand() % 10000;
            while (game_running)
            {
                displayNumber(ran);
                updateInputRegisters(&prevB, &currB, &prevE, &currE);

                //Counter is printed on screen (initially 0), and user can increase the number.
                if (detectEdge(prevE, currE, 1, 1))
                {
                    while (!detectEdge(prevE, currE, 2, 1))
                    {
                        displayNumber(contador);
                        updateInputRegisters(&prevB, &currB, &prevE, &currE);
                        inputNumbers(&contador, &prevB, &currB);
                    }
                    //User has submitted his number. We now compare the user number with our random number.
                    if (contador == ran) winner();
                    else loser();
                    
                    //This loop prints the correct number on screen for 5 seconds.
                    for (int i = 0; i < 300; ++i) displayNumber(ran);

                    //Turn off winner/loser LEDs.
                    PORTC = 0;

                    //End of game and setup for next one
                    game_running = false;
                    displayOff();
                    contador = 0;
                }
            }
        }
    }
}
